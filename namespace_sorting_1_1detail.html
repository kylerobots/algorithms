<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithms: Sorting::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Algorithms
   &#160;<span id="projectnumber">0.1.0.0</span>
   </div>
   <div id="projectbrief">A collection of algorithms covered in my Algorithms course.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_sorting.html">Sorting</a></li><li class="navelem"><a class="el" href="namespace_sorting_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sorting::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a namespace with some under the hood functions.  
<a href="namespace_sorting_1_1detail.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab97003fada199e6a45a4da3afaf3de74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting_1_1detail.html#ab97003fada199e6a45a4da3afaf3de74">maxHeapify</a> (std::vector&lt; double &gt; &amp;array, size_t heap_size, size_t current_index)</td></tr>
<tr class="memdesc:ab97003fada199e6a45a4da3afaf3de74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an array to have the heap property.  <a href="namespace_sorting_1_1detail.html#ab97003fada199e6a45a4da3afaf3de74">More...</a><br /></td></tr>
<tr class="separator:ab97003fada199e6a45a4da3afaf3de74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012f959f3d4f1ea5c3ae1530f3e3e7d9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting_1_1detail.html#a012f959f3d4f1ea5c3ae1530f3e3e7d9">buildMaxHeap</a> (const std::vector&lt; double &gt; &amp;input)</td></tr>
<tr class="memdesc:a012f959f3d4f1ea5c3ae1530f3e3e7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a heap-like array for sorting via Heap sort.  <a href="namespace_sorting_1_1detail.html#a012f959f3d4f1ea5c3ae1530f3e3e7d9">More...</a><br /></td></tr>
<tr class="separator:a012f959f3d4f1ea5c3ae1530f3e3e7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cd60b15815b923e3721ef389a57be6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting_1_1detail.html#a95cd60b15815b923e3721ef389a57be6">merge</a> (std::vector&lt; double &gt; &amp;input, size_t p, size_t q, size_t r)</td></tr>
<tr class="memdesc:a95cd60b15815b923e3721ef389a57be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The helper function that performs the actual merge of mergesort.  <a href="namespace_sorting_1_1detail.html#a95cd60b15815b923e3721ef389a57be6">More...</a><br /></td></tr>
<tr class="separator:a95cd60b15815b923e3721ef389a57be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a2abab763292068c165b861cb8ba56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting_1_1detail.html#a88a2abab763292068c165b861cb8ba56">mergeSort</a> (std::vector&lt; double &gt; &amp;input, size_t start_index, size_t end_index)</td></tr>
<tr class="memdesc:a88a2abab763292068c165b861cb8ba56"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function for merge sort that divides the problem.  <a href="namespace_sorting_1_1detail.html#a88a2abab763292068c165b861cb8ba56">More...</a><br /></td></tr>
<tr class="separator:a88a2abab763292068c165b861cb8ba56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06c915d205f486fd043595f7710806c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting_1_1detail.html#ad06c915d205f486fd043595f7710806c">quickPartition</a> (std::vector&lt; double &gt; &amp;input, size_t start_index, size_t end_index)</td></tr>
<tr class="memdesc:ad06c915d205f486fd043595f7710806c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the partition operation for quick sort.  <a href="namespace_sorting_1_1detail.html#ad06c915d205f486fd043595f7710806c">More...</a><br /></td></tr>
<tr class="separator:ad06c915d205f486fd043595f7710806c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cb1af58103795c9cfed623fddcfa8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting_1_1detail.html#a58cb1af58103795c9cfed623fddcfa8b">quickSort</a> (std::vector&lt; double &gt; &amp;input, size_t start_index, size_t end_index)</td></tr>
<tr class="memdesc:a58cb1af58103795c9cfed623fddcfa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function for the quicksort divide and conquer.  <a href="namespace_sorting_1_1detail.html#a58cb1af58103795c9cfed623fddcfa8b">More...</a><br /></td></tr>
<tr class="separator:a58cb1af58103795c9cfed623fddcfa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c65925ba3194f4a0550d42c5c49ca6c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting_1_1detail.html#a5c65925ba3194f4a0550d42c5c49ca6c">radixCountSort</a> (const std::vector&lt; unsigned int &gt; &amp;input, unsigned int digit)</td></tr>
<tr class="memdesc:a5c65925ba3194f4a0550d42c5c49ca6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified counting sort that operates on a single digit for each number.  <a href="namespace_sorting_1_1detail.html#a5c65925ba3194f4a0550d42c5c49ca6c">More...</a><br /></td></tr>
<tr class="separator:a5c65925ba3194f4a0550d42c5c49ca6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a namespace with some under the hood functions. </p>
<p>These should generally not be called by the user unless you are very sure what you are doing and have a very good reason for doing so. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a012f959f3d4f1ea5c3ae1530f3e3e7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012f959f3d4f1ea5c3ae1530f3e3e7d9">&#9670;&nbsp;</a></span>buildMaxHeap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; Sorting::detail::buildMaxHeap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a heap-like array for sorting via Heap sort. </p>
<p>This puts the array in such an order that its heap property is maintained. It does this by inserting elements and calling <a class="el" href="namespace_sorting_1_1detail.html#ab97003fada199e6a45a4da3afaf3de74">maxHeapify</a> to ensure compliance with the heap property. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The array to heapify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array in heap structure. </dd></dl>

</div>
</div>
<a id="ab97003fada199e6a45a4da3afaf3de74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97003fada199e6a45a4da3afaf3de74">&#9670;&nbsp;</a></span>maxHeapify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sorting::detail::maxHeapify </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>heap_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>current_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an array to have the heap property. </p>
<p>This recursively ensures that a given vector satisfies the heap property with the first, root element being the maximum. This is called recursively and assumes that all elements lower than lowest_index already meet the heap property. It takes the target index and moves it into the correct spot down the array to maintain the heap property. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to make into a heap. </td></tr>
    <tr><td class="paramname">heap_size</td><td>The maximum element that is considered part of the heap. </td></tr>
    <tr><td class="paramname">current_index</td><td>The current index to consider. It assumes all larger then this are already in heap order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95cd60b15815b923e3721ef389a57be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cd60b15815b923e3721ef389a57be6">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sorting::detail::merge </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The helper function that performs the actual merge of mergesort. </p>
<p>This creates the two stacks, which are already in sorted order, and pops whichever value off the top is smaller. This leads to a single array that is completely sorted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The array to sort. This will be operated on in-place. </td></tr>
    <tr><td class="paramname">p</td><td>The smallest index to include in the sort. </td></tr>
    <tr><td class="paramname">q</td><td>The midpoint of the sorting selection. It is assumed that and values from [p, q] are already sorted as well as all values from [q+1, r]. </td></tr>
    <tr><td class="paramname">r</td><td>The largest index to include in the sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88a2abab763292068c165b861cb8ba56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a2abab763292068c165b861cb8ba56">&#9670;&nbsp;</a></span>mergeSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sorting::detail::mergeSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function for merge sort that divides the problem. </p>
<p>This method recursively divides up the array into half. Eventually, the problem is broken down into individual elements, which are by definition sorted. This then uses <a class="el" href="namespace_sorting_1_1detail.html#a95cd60b15815b923e3721ef389a57be6">merge</a> to combine the elements back together in sorted order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The vector to operate on. This will be modified in place. </td></tr>
    <tr><td class="paramname">start_index</td><td>The smallest index to consider in sorting. </td></tr>
    <tr><td class="paramname">end_index</td><td>The largest index to consider in sorting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad06c915d205f486fd043595f7710806c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06c915d205f486fd043595f7710806c">&#9670;&nbsp;</a></span>quickPartition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Sorting::detail::quickPartition </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the partition operation for quick sort. </p>
<p>This function takes the last value in the supplied range and uses it as a pivot. It then walks through the array and ensures that each value less then the pivot is on the left and greater than on the right. It will then put the pivot in the middle of the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The array to partition. </td></tr>
    <tr><td class="paramname">start_index</td><td>The first index to include in the partition. </td></tr>
    <tr><td class="paramname">end_index</td><td>The last index to include in the partition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index around which the array is partitioned. </dd></dl>

</div>
</div>
<a id="a58cb1af58103795c9cfed623fddcfa8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cb1af58103795c9cfed623fddcfa8b">&#9670;&nbsp;</a></span>quickSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sorting::detail::quickSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function for the quicksort divide and conquer. </p>
<p>This part partitions each array, then calls itself for each partition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The array to sort. </td></tr>
    <tr><td class="paramname">start_index</td><td>The first index to include in the sort. </td></tr>
    <tr><td class="paramname">end_index</td><td>The last index to include in the sort. @ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c65925ba3194f4a0550d42c5c49ca6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c65925ba3194f4a0550d42c5c49ca6c">&#9670;&nbsp;</a></span>radixCountSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned int&gt; Sorting::detail::radixCountSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>digit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A modified counting sort that operates on a single digit for each number. </p>
<p>This uses the same algorithm as <a class="el" href="namespace_sorting.html#ae10653e560cb5607137ca9147b40b70a">countingSort</a>, but only compares a single digit for each number, rather than the whole number. Because of that, it only needs to allocate 10 spaces for the count. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The vector to sort. </td></tr>
    <tr><td class="paramname">digit</td><td>The digit index to sort on. 0 = ones place, 1 = tens place, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array sorted on the select digit. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
