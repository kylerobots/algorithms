<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithms: detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Algorithms
   &#160;<span id="projectnumber">0.1.0.0</span>
   </div>
   <div id="projectbrief">A collection of algorithms covered in my Algorithms course.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a namespace with some under the hood functions.  
<a href="namespacedetail.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a28d2892e828402020ff501c531ca3c4c"><td class="memItemLeft" align="right" valign="top"><a id="a28d2892e828402020ff501c531ca3c4c"></a>
typedef std::vector&lt; std::vector&lt; unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a28d2892e828402020ff501c531ca3c4c">Values</a></td></tr>
<tr class="memdesc:a28d2892e828402020ff501c531ca3c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The table that stores the values for each pair of characters. <br /></td></tr>
<tr class="separator:a28d2892e828402020ff501c531ca3c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27d67c5314d554b0441bcd5df9ddda4"><td class="memItemLeft" align="right" valign="top"><a id="af27d67c5314d554b0441bcd5df9ddda4"></a>
typedef std::vector&lt; std::vector&lt; <a class="el" href="namespacedetail.html#af5904b1e9c1aa04176606c336442bc8e">Direction</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail.html#af27d67c5314d554b0441bcd5df9ddda4">Directions</a></td></tr>
<tr class="memdesc:af27d67c5314d554b0441bcd5df9ddda4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The table that stores teh directions for each pair of characters. <br /></td></tr>
<tr class="separator:af27d67c5314d554b0441bcd5df9ddda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af5904b1e9c1aa04176606c336442bc8e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail.html#af5904b1e9c1aa04176606c336442bc8e">Direction</a> { <b>DIAGONAL</b>
, <b>LEFT</b>
, <b>NOTHING</b>
, <b>UP</b>
 }</td></tr>
<tr class="memdesc:af5904b1e9c1aa04176606c336442bc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A representation of the directions stored in the table.  <a href="namespacedetail.html#af5904b1e9c1aa04176606c336442bc8e">More...</a><br /></td></tr>
<tr class="separator:af5904b1e9c1aa04176606c336442bc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a176ae6c590a190539e22318f280063b0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedetail.html#a28d2892e828402020ff501c531ca3c4c">Values</a>, <a class="el" href="namespacedetail.html#af27d67c5314d554b0441bcd5df9ddda4">Directions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a176ae6c590a190539e22318f280063b0">computeLCS</a> (const std::string &amp;string1, const std::string &amp;string2)</td></tr>
<tr class="memdesc:a176ae6c590a190539e22318f280063b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tables used for finding the LCS.  <a href="namespacedetail.html#a176ae6c590a190539e22318f280063b0">More...</a><br /></td></tr>
<tr class="separator:a176ae6c590a190539e22318f280063b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9505bbe65c2f8cfb48c2a3e5be87720"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail.html#af9505bbe65c2f8cfb48c2a3e5be87720">printLCS</a> (const <a class="el" href="namespacedetail.html#af27d67c5314d554b0441bcd5df9ddda4">Directions</a> &amp;direction, const std::string &amp;string1, size_t length1, size_t length2)</td></tr>
<tr class="memdesc:af9505bbe65c2f8cfb48c2a3e5be87720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the computed solution tables and recursively extracts the LCS.  <a href="namespacedetail.html#af9505bbe65c2f8cfb48c2a3e5be87720">More...</a><br /></td></tr>
<tr class="separator:af9505bbe65c2f8cfb48c2a3e5be87720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d584dc8ef8459f8ff5b8e28673f844"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; size_t, size_t, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a04d584dc8ef8459f8ff5b8e28673f844">findMaxCrossingArray</a> (const std::vector&lt; float &gt; &amp;input, size_t low, size_t mid, size_t high)</td></tr>
<tr class="memdesc:a04d584dc8ef8459f8ff5b8e28673f844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximum subarray that is guaranteed to cross the value of mid.  <a href="namespacedetail.html#a04d584dc8ef8459f8ff5b8e28673f844">More...</a><br /></td></tr>
<tr class="separator:a04d584dc8ef8459f8ff5b8e28673f844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff44228e385ffb46608913313e23f80f"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; size_t, size_t, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail.html#aff44228e385ffb46608913313e23f80f">findMaxSubarray</a> (const std::vector&lt; float &gt; &amp;input, size_t low, size_t high)</td></tr>
<tr class="memdesc:aff44228e385ffb46608913313e23f80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively find the maximum subarray.  <a href="namespacedetail.html#aff44228e385ffb46608913313e23f80f">More...</a><br /></td></tr>
<tr class="separator:aff44228e385ffb46608913313e23f80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a namespace with some under the hood functions. </p>
<p>These should generally not be called by the user unless you are very sure what you are doing and have a very good reason for doing so. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="af5904b1e9c1aa04176606c336442bc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5904b1e9c1aa04176606c336442bc8e">&#9670;&nbsp;</a></span>Direction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedetail.html#af5904b1e9c1aa04176606c336442bc8e">detail::Direction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A representation of the directions stored in the table. </p>
<p>These represent the different directions used to determine how to walk along the substring solution table. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a176ae6c590a190539e22318f280063b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176ae6c590a190539e22318f280063b0">&#9670;&nbsp;</a></span>computeLCS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedetail.html#a28d2892e828402020ff501c531ca3c4c">Values</a>, <a class="el" href="namespacedetail.html#af27d67c5314d554b0441bcd5df9ddda4">Directions</a>&gt; detail::computeLCS </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the tables used for finding the LCS. </p>
<p>This creates two tables. One stores the values given in the recursive formula. The other gives th directions used to reconstruct the string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string1</td><td>The first string to compare. </td></tr>
    <tr><td class="paramname">string2</td><td>The second string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of the two tables. </dd></dl>

</div>
</div>
<a id="a04d584dc8ef8459f8ff5b8e28673f844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d584dc8ef8459f8ff5b8e28673f844">&#9670;&nbsp;</a></span>findMaxCrossingArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;size_t, size_t, double&gt; detail::findMaxCrossingArray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the maximum subarray that is guaranteed to cross the value of mid. </p>
<p>Since the goal is to find a crossing array, this algorithm starts in the middle and extends out in each direction. At each new index, it computes the new total to determine if the inclusion of the extra element results in a larger sum total. Once finished, it adds both directions together for the complete crossing array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The array to search. </td></tr>
    <tr><td class="paramname">low</td><td>The lowest index to include in the search. </td></tr>
    <tr><td class="paramname">mid</td><td>The middle value that is guaranteed to be part of the array. </td></tr>
    <tr><td class="paramname">high</td><td>The highest index to include in the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple with the lower and upper indices for the crossing array, as well as the total sum. </dd></dl>

</div>
</div>
<a id="aff44228e385ffb46608913313e23f80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff44228e385ffb46608913313e23f80f">&#9670;&nbsp;</a></span>findMaxSubarray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;size_t, size_t, double&gt; detail::findMaxSubarray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively find the maximum subarray. </p>
<p>This function considers three cases. Either the max array is entirely in the left, entirely in the right, or crosses some midpoint. This is then broken down into subproblems until the left and right are each only one element long. The results are then compared as the solution is reassembled. Each result is either a left or right for comparision in the next higher iteration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The array to search through. </td></tr>
    <tr><td class="paramname">low</td><td>The smallest index to include. </td></tr>
    <tr><td class="paramname">high</td><td>The highest index to include. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple with the lower and upper indices for the maximum array, as well as the total sum. </dd></dl>

</div>
</div>
<a id="af9505bbe65c2f8cfb48c2a3e5be87720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9505bbe65c2f8cfb48c2a3e5be87720">&#9670;&nbsp;</a></span>printLCS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string detail::printLCS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#af27d67c5314d554b0441bcd5df9ddda4">Directions</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes the computed solution tables and recursively extracts the LCS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>The table that stores directions. </td></tr>
    <tr><td class="paramname">string1</td><td>One of the strings, used to extract characters. </td></tr>
    <tr><td class="paramname">length1</td><td>The length of the substring solution for string1. </td></tr>
    <tr><td class="paramname">length2</td><td>The length of the substring solution for the other string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the longest common substring. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
