<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithms: Sorting Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Algorithms
   &#160;<span id="projectnumber">0.1.0.0</span>
   </div>
   <div id="projectbrief">A collection of algorithms covered in my Algorithms course.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sorting Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of sorting algorithms discussed in class.  
<a href="namespace_sorting.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_sorting_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespace_sorting_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a namespace with some under the hood functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a37c426ff92190078632154f778f0b0e2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting.html#a37c426ff92190078632154f778f0b0e2">insertionSort</a> (const std::vector&lt; double &gt; &amp;input)</td></tr>
<tr class="memdesc:a37c426ff92190078632154f778f0b0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sort via insertion.  <a href="namespace_sorting.html#a37c426ff92190078632154f778f0b0e2">More...</a><br /></td></tr>
<tr class="separator:a37c426ff92190078632154f778f0b0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115cb983369e4ff154bf63c447933d4e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting.html#a115cb983369e4ff154bf63c447933d4e">mergeSort</a> (const std::vector&lt; double &gt; &amp;input)</td></tr>
<tr class="memdesc:a115cb983369e4ff154bf63c447933d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sorting via merge sort.  <a href="namespace_sorting.html#a115cb983369e4ff154bf63c447933d4e">More...</a><br /></td></tr>
<tr class="separator:a115cb983369e4ff154bf63c447933d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3dcbcbf87ab395dbe7b8c750e2ea21"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting.html#a9c3dcbcbf87ab395dbe7b8c750e2ea21">heapSort</a> (const std::vector&lt; double &gt; &amp;input)</td></tr>
<tr class="memdesc:a9c3dcbcbf87ab395dbe7b8c750e2ea21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sorting via heap sort.  <a href="namespace_sorting.html#a9c3dcbcbf87ab395dbe7b8c750e2ea21">More...</a><br /></td></tr>
<tr class="separator:a9c3dcbcbf87ab395dbe7b8c750e2ea21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae2cdc300a6440afd1e3e6699de6018"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting.html#afae2cdc300a6440afd1e3e6699de6018">quickSort</a> (const std::vector&lt; double &gt; &amp;input)</td></tr>
<tr class="memdesc:afae2cdc300a6440afd1e3e6699de6018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sorting via quicksort.  <a href="namespace_sorting.html#afae2cdc300a6440afd1e3e6699de6018">More...</a><br /></td></tr>
<tr class="separator:afae2cdc300a6440afd1e3e6699de6018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10653e560cb5607137ca9147b40b70a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting.html#ae10653e560cb5607137ca9147b40b70a">countingSort</a> (const std::vector&lt; uint8_t &gt; &amp;input)</td></tr>
<tr class="memdesc:ae10653e560cb5607137ca9147b40b70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sorting via counting sort.  <a href="namespace_sorting.html#ae10653e560cb5607137ca9147b40b70a">More...</a><br /></td></tr>
<tr class="separator:ae10653e560cb5607137ca9147b40b70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e00eb2eaff5f15a3483a5e0133b909"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting.html#a83e00eb2eaff5f15a3483a5e0133b909">radixSort</a> (const std::vector&lt; unsigned int &gt; &amp;input)</td></tr>
<tr class="memdesc:a83e00eb2eaff5f15a3483a5e0133b909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sorting via radix sort.  <a href="namespace_sorting.html#a83e00eb2eaff5f15a3483a5e0133b909">More...</a><br /></td></tr>
<tr class="separator:a83e00eb2eaff5f15a3483a5e0133b909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe9aeeb7882b4c192beb3615bdab32e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sorting.html#a5fe9aeeb7882b4c192beb3615bdab32e">bucketSort</a> (const std::vector&lt; double &gt; &amp;input)</td></tr>
<tr class="memdesc:a5fe9aeeb7882b4c192beb3615bdab32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sorting via bucket sort.  <a href="namespace_sorting.html#a5fe9aeeb7882b4c192beb3615bdab32e">More...</a><br /></td></tr>
<tr class="separator:a5fe9aeeb7882b4c192beb3615bdab32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A collection of sorting algorithms discussed in class. </p>
<p>This includes the following algorithms and the types of inputs the handle (stored within std::vector):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">algorithm   </th><th class="markdownTableHeadNone">input type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">insertion   </td><td class="markdownTableBodyNone">double    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">merge   </td><td class="markdownTableBodyNone">double    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">heap   </td><td class="markdownTableBodyNone">double    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">quick   </td><td class="markdownTableBodyNone">double    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">counting   </td><td class="markdownTableBodyNone">uint8_t    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">radix   </td><td class="markdownTableBodyNone">unsigned int    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bucket   </td><td class="markdownTableBodyNone">double in the range [0, 1)   </td></tr>
</table>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5fe9aeeb7882b4c192beb3615bdab32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe9aeeb7882b4c192beb3615bdab32e">&#9670;&nbsp;</a></span>bucketSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; Sorting::bucketSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform sorting via bucket sort. </p>
<p>This algorithm divides the valid range for the sort into n uniform buckets. It then places each number into the appropriate bucket. These buckets are then sorted via insertion sort. The buckets are then reassembled. Because the buckets contain only a few items, the insertion sort is fast.</p>
<dl class="section note"><dt>Note</dt><dd>This can be expanded to any nonnegative value by normalizing the values when placing into buckets. However, this will stick with the method shown in the book.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A vector of unsorted numbers in the range [0, 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Those numbers sorted from smallest to largest. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown if a number is outside the range [0, 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae10653e560cb5607137ca9147b40b70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10653e560cb5607137ca9147b40b70a">&#9670;&nbsp;</a></span>countingSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint8_t&gt; Sorting::countingSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform sorting via counting sort. </p>
<p>This method assumes the input is all nonnegative integers. It sorts by counting up the number of instances of each possible integer and using that to determine where that integer should be placed within the ouput array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A vector of unsorted integers &gt;= 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Those numbers sorted from smallest to largest. </dd></dl>

</div>
</div>
<a id="a9c3dcbcbf87ab395dbe7b8c750e2ea21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3dcbcbf87ab395dbe7b8c750e2ea21">&#9670;&nbsp;</a></span>heapSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; Sorting::heapSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform sorting via heap sort. </p>
<p>This method builds a heap out of the data then reads it in printed order. The heap is a max heap, meaning each element is greater than its parents. Therefore, it is easy to traverse to get an ordered array. Various subfunctions ensure that the heap property is maintained. Unlike <a class="el" href="namespace_sorting.html#a115cb983369e4ff154bf63c447933d4e">mergeSort</a>, this sorts in place. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A vector of numbers in any order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Those numbers sorted from smallest to largest. </dd></dl>

</div>
</div>
<a id="a37c426ff92190078632154f778f0b0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c426ff92190078632154f778f0b0e2">&#9670;&nbsp;</a></span>insertionSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; Sorting::insertionSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform sort via insertion. </p>
<p>This is the simplist code, but also the most costly in terms of performance. It does operate in place though, so there are only fixed memory costs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The unsorted array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The provided array, sorted from least to greatest. </dd></dl>

</div>
</div>
<a id="a115cb983369e4ff154bf63c447933d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115cb983369e4ff154bf63c447933d4e">&#9670;&nbsp;</a></span>mergeSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; Sorting::mergeSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform sorting via merge sort. </p>
<p>This method is faster than insertion sort, but does take up additional memory, due to the temporary arrays created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A vector of numbers in any order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Those numbers sorted from smallest to largest. </dd></dl>

</div>
</div>
<a id="afae2cdc300a6440afd1e3e6699de6018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae2cdc300a6440afd1e3e6699de6018">&#9670;&nbsp;</a></span>quickSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; Sorting::quickSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform sorting via quicksort. </p>
<p>This method uses quicksort, which recursively partitions the data into halves that are greater or less than a selected pivot value. Eventually, the halves are small enough that they are automatically sorted. This is the same asymptotic complexity as some oft the other algorithms, but often performs faster. There is a randomized version that avoids the worst case. This is not that version. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A vector of unsorted numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Those numbers sorted from smallest to largest. </dd></dl>

</div>
</div>
<a id="a83e00eb2eaff5f15a3483a5e0133b909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e00eb2eaff5f15a3483a5e0133b909">&#9670;&nbsp;</a></span>radixSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned int&gt; Sorting::radixSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform sorting via radix sort. </p>
<p>This uses a radix sort to sort on each digit from least to most significant digit. It then uses a modified counting sort algorithm under the hood for the actual sort. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A vector of unsorted integers &gt;= 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Those numbers sorted from smallest to largest. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
